
<html>
  <meta charset="utf-8">
  <title>Vizsla</title>
  <link href="https://fonts.googleapis.com/css?family=Cutive+Mono|Sorts+Mill+Goudy|Mate|Oxygen+Mono|Offside|Raleway:400,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy">
  <link rel="stylesheet" type="text/css" href="css/ascetic.css">
  <link rel="stylesheet" type="text/css" href="css/style.css">
</html>
<body>
  <div class="container">
    <div class="unit description">
      <div class="entry">
        <h2>Thu Oct 26 2017 19:10:33 GMT-0500 (CDT)</h2>
        <div class="markdown"><p>Vizsla is supposed to have a default opinionated mode about HTTP. For the most
part I&apos;m sending and receiving JSON payloads between servers using HTTP. I&apos;m not
making extensive use of error codes. I&apos;m making no use of REST as it is defined
by Ruby on Rails with it&apos;s proscription for mixing URL paths and verbs. There is
no caching between services, so everything is a JSON up and JSON down.</p>
<p>This is the general use of Vizsla in my applications. With the Paxos algorithm,
any error is considered fatal. With this I use the <code>nullify</code> flag with Vizla so
than if anything bad happens, the request returns null. After a retry or two we
run the Paxos algorithm to reshape the network topology and remove the bad
service.</p>
<p>The response is binary. Vizsla works okay for this.</p>
<p>There are boundaries where a service that is expecting HTTP codes enters into a
system I&apos;ve created that is using HTTP for it&apos;s network communication.</p>
<p>The problem that I have is that I want to have a single status code for an HTTP
request. The requester is going to respond differently for three different
states. A 2xx means everything is okay. A 404 means that an object is not
present and the caller will stop asking about it. Any other 4xx or 5xx means
something bad happened and the caller try again later.</p>
<p>With this, I&apos;m generally interested in returning a payload with 200 or else
reutrning 404 if the object is missing or 5xx if something bad happens. I&apos;m
propaging these error messages through a network of servers.</p>
<p>Unlike Paxos where I get a return value or null, here I really do want to
inspect the status codes and make decisions based on them.</p>
<p>So, I&apos;ve come to a place where I want to have way of working with HTTP, but I
still want to corral all of the errors into a single error code.</p>
<p>This is where I&apos;ve been confused about how to funnel all of HTTP&apos;s problems into
a single HTTP response.</p>
<p>If there is a socket connection failure it is the same to the caller as if there
was a gateway error at a load balancer. Vizsla has already made the decision to
turn this into a 599 error code. This 599 error code is already out there in the
wild as an unoffical error code.</p>
<p>It is no problem to set this error code because if I cannot connect then the
error code would be unset anyway. Plan Node.js HTTP would generate an <code>&quot;error&quot;</code>
event. I don&apos;t want to have to hook up two different error handling mechanisms
for each HTTP request. Vizsla was supposed to be about slurping.</p>
<p>The problem is with the result. In my opinionated mode, I want to assume that I
get good JSON back from the caller. If I get bad JSON I want to say that the
request failed even if it succeeded. Except that unlike a failed socket
conneciton, by the time I&apos;m parsing JSON I already have an error code. If I set
an error code I am overwritting an error.</p>
<p>That doesn&apos;t seem like a bad thing, but it is. Vizsla itself is a client. It
doesn&apos;t make sense for Vizsla to rewrite server responses.</p>
<p>In fact, from what I can see, once the response is created, Node.js will no
longer raise an exception. Any error that occurs thereafter will result in the
response stream being truncated if the error occurs before the end of stream
message is sent.</p>
<p>Thus, the streaming result is an application problem according to Node.js, but I
don&apos;t want it to be. I want simple error-first callback calls to get a JSON
response.</p>
<p>And yet, I can imagine that if I had a proxy server between myself and the
service returning bad JSON, I&apos;d be okay with the proxy server returning a 502
error. In fact, a garbled stream response really ought to erode my faith that
all is okay in the world desipte a 2xx status code.</p>
<p>I can see myself writing a proxy. I can see that I already accept that an error
from a proxy means that the proxy logged the error, I don&apos;t need to receive a
huge chained error message as a payload, nor should I. Stack traces and error
messages belong in logs, not in responses.</p>
<p>So, rather than try and slide this into Vizsla the client, it makes sense to me
to adopt some sort of middleware. That middleware can act as an in-memory
gateway and failures to connect can be 503 errors and failures to parse a
response can be 502. That middleware can have some sort of logging for the
errors.</p>
<p>The nature of the middleware is another matter. Could it be Sencha connect
middleware. Yes, we already support using it for mocking. But, we probably don&apos;t
want to serialize and deserialize JSON in memory, just return it.</p>
<p>Also, the middleware might be itself opininated or specific to a paritcular
problem. It might not be prepare to handle streaming content or parse XML. It is
written as a gateway to handle specific cases.</p>
<p>Finally, with these specific cases you could decide that you want to create
middleware that dispatches based on URL. I&apos;d say that might be overdoing it for
most cases. If you wanted to use a middleware that does some sort of fancy
streaming then you could create an instance of Vizsla that has just that
middleware, probably based on a common instance of Vizsla.</p>
</div>
      </div>
      <div class="entry">
        <h2>Sat Apr 22 2017 12:20:05 GMT-0500 (CDT)</h2>
        <div class="markdown"><p>Revisited Vizsla today. Saw the two stage code and immediately want it gone. It
is for the special case of client credentials OAuth. That is a state transition.
It should not be transparent. You can easily create a Vizsla that wraps the
authentication, then give that to your objects. When you reach a 401 you&apos;re
going to get an exception, so you&apos;re going to have to retry. That retry should
be outside of Vizsla somewhere.</p>
</div>
      </div>
      <div class="entry">
        <h2>Thu Apr 06 2017 01:37:35 GMT-0500 (CDT)</h2>
        <div class="markdown"><p>Had a go at implementing streams through Vizsla.</p>
<p>Problem with this is that we are putting a hidden call prior to making our call
to resolve authentication, which is fine, but it means that we shouldn&#x2019;t be
ready to receive any messages until we&#x2019;ve gone through the asynchronous read
step, which in turn means that we need an asynchronous wait step before we can
write our buffer.</p>
<p>Also, wanted to make streams return, so instead of returning a parsed body,
response and then a buffer, I got rid of the buffer.</p>
<p>Sorting out how to send an error and settling on JSON body format for errors so
that they can be serialized and dealt with programmatically. This means that the
error was already JSON, so we keep it as JSON, or plain text so we can keep it
as that, or else it is some sort of hell that needs to be base64 encoded if it
is not application JSON or plain text. Then we can have an object or utilities
that will allow us to parse it or otherwise deal with it. Ah, it could also be
<code>text/html</code> so that is one more type we can leave as plain text.</p>
<p>The problem is that Vizsla does stuff on our behalf, so we have to pass through
the CC and other authentication hoops to get to an error which is why error
responses are annoying. We might be expecting a streaming response, hmm&#x2026; Well if
we get some terrible streaming response as an error message, like an error
video, that is really hellish, yeah. We can pretend that all requests are going
through a proxy such that we are always returning headers that are appropriate
for our content, converting the response to contain our nested error message
that needs to be cracked. I&#x2019;m trying to make proxies easier.</p>
<p>Keeping that raw buffer on parse might be the easiest way to have something to
return form <code>cc.js</code>.</p>
<p>TK Come back and rewrite this. They where notes along the way.</p>
</div>
      </div>
    </div>
  </div>
</body>
<!-- vim: set ts=2 sw=2 nowrap:-->
